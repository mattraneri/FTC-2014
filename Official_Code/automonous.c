#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTServo)
#pragma config(Sensor, S2,     irSensor,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     touchSensor,    sensorTouch)
#pragma config(Sensor, S4,     sonarSensor,               sensorSONAR)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,          motorFlag,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorBR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorBL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     motorFR,       tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     motorFL,       tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_1,     motorPlat,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     motorArm,      tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S1_C4_1,    rightPlow,            tServoStandard)
#pragma config(Servo,  srvo_S1_C4_2,    leftPlow,             tServoStandard)
#pragma config(Servo,  srvo_S1_C4_3,    servo4,               tServoStandard)
#pragma config(Servo,  srvo_S1_C4_4,    basket,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C4_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "globals.c"
#include "JoystickDriver.c"  				//Include file to "handle" the Bluetooth messages.
#include "drivers/hitechnic-irseeker-v2.h"


void initializeRobot()
{
	// Place code here to initialize servos to starting positions.
	// Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.
	//initServos();
	servo[basket] = 15;//90
	return;
}


void rightPark() {
	motor[motorFL] = 100;
	motor[motorFR] = 100;
	motor[motorBL] = 100;
	motor[motorBR] = 100;
	wait1Msec(1100);
	motor[motorFL] = 00;
	motor[motorFR] = 00;
	motor[motorBL] = 00;
	motor[motorBR] = 00;
	wait1Msec(100);
	motor[motorFL] = 100;
	motor[motorFR] = -100;
	motor[motorBL] = 100;
	motor[motorBR] = -100;
	wait1Msec(350);
	motor[motorFL] = 00;
	motor[motorFR] = 00;
	motor[motorBL] = 00;
	motor[motorBR] = 00;
	wait1Msec(100);
	motor[motorFL] = 100;
	motor[motorFR] = 100;
	motor[motorBL] = 100;
	motor[motorBR] = 100;
	wait1Msec(1300);
	motor[motorFL] = 00;
	motor[motorFR] = 00;
	motor[motorBL] = 00;
	motor[motorBR] = 00;
}

void leftPark() {
	motor[motorFL] = 100;
	motor[motorFR] = 100;
	motor[motorBL] = 100;
	motor[motorBR] = 100;
	wait1Msec(1100);
	motor[motorFL] = 00;
	motor[motorFR] = 00;
	motor[motorBL] = 00;
	motor[motorBR] = 00;
	wait1Msec(1000);
	motor[motorFL] = -100;
	motor[motorFR] = 100;
	motor[motorBL] = -100;
	motor[motorBR] = 100;
	wait1Msec(350);
	motor[motorFL] = 00;
	motor[motorFR] = 00;
	motor[motorBL] = 00;
	motor[motorBR] = 00;
	wait1Msec(1000);
	motor[motorFL] = 100;
	motor[motorFR] = 100;
	motor[motorBL] = 100;
	motor[motorBR] = 100;
	wait1Msec(1300);
	motor[motorFL] = 00;
	motor[motorFR] = 00;
	motor[motorBL] = 00;
	motor[motorBR] = 00;
}

void parkOnRamp(int state) {
	switch(state) {
		case 0:
			rightPark();
			break;
		case 1:
			leftPark();
			break;
	}
}

void zeroMotors() {
	motor[motorFR] =  0;
	motor[motorBR] =  0;
	motor[motorBL] =  0;
	motor[motorFL] =  0;
}


void dropIn() {
	zeroMotors();
	bool didPress = false;
	int a = 0;
	while(didPress == false) {
		motor[motorFR] = -20;
		motor[motorBR] = -20;
		motor[motorFL] = -20;
		motor[motorBL] = -20;
		a = SensorValue[touchSensor];
		if(a == 0) {
		} else {
			didPress = true;
		}
	}
	zeroMotors();
	wait1Msec(100);

	motor[motorFR] = 20;
	motor[motorBR] = 20;
	motor[motorFL] = 20;
	motor[motorBL] = 20;
	wait1Msec(250);
	zeroMotors();
	motor[motorArm] = -50;
	wait1Msec(850);
	motor[motorArm] = 0;
	servo[basket] =  180;
	wait1Msec(1500);
	servo[basket] =  0;
	motor[motorArm] = 50;
	wait1Msec(700);
	motor[motorArm] = 0;
	motor[motorFR] = 24;
	motor[motorBR] = 20;
	motor[motorFL] = 20;
	motor[motorBL] = 20;
	wait1Msec(420);

}


void setupRight() {
	motor[motorFR] =  50;
	motor[motorBR] =  50;
	motor[motorBL] =  50;
	motor[motorFL] =  50;
	wait1Msec(200);
	zeroMotors();
	wait1Msec(200);
	motor[motorFR] = -50;
	motor[motorBR] = -50;
	motor[motorBL] = 50;
	motor[motorFL] = 50;
	wait1Msec(650);
	zeroMotors();
	wait1Msec(200);
	motor[motorFR] =  50;
	motor[motorBR] =  50;
	motor[motorBL] =  50;
	motor[motorFL] =  50;
	wait1Msec(1500);
	zeroMotors();
	wait1Msec(600);
	motor[motorFR] = -50;
	motor[motorBR] = -50;
	motor[motorFL] = 50;
	motor[motorBL] = 50;
	wait1Msec(490);
	zeroMotors();
	//Take out once perfected
	wait1Msec(2000);
}

task main()
 {
  initializeRobot();



  //VV Do not touch VV

  //motor[motorArm] = 50;
  //wait1Msec(100000);
  waitForStart();


  wait1Msec(7000);

  setupRight();

	int sense = 0;
	bool didDrop = false;

  while(didDrop == false) {
    sense = SensorValue[irSensor];
    nxtDisplayString(2, "%d", sense);
		motor[motorFL] = -20;
  	motor[motorFR] = 20;
  	motor[motorBL] = 20;
  	motor[motorBR] = -20;
    if(sense == 5) {
    	wait1Msec(1400);
    	dropIn();
    	didDrop = true;
    	zeroMotors();
  	} else {
  		motor[motorFL] = -20;
  		motor[motorFR] = 20;
  		motor[motorBL] = 20;
  		motor[motorBR] = -20;
  	}
  }
  zeroMotors();


  int a = 0;
  bool isClear = false;
	while(isClear == false) {
		a = SensorValue[sonarSensor];
		if(a < 50) {
			motor[motorFR] = -50;
			motor[motorBR] = 50;
			motor[motorFL] = 50;
			motor[motorBL] = -50;
		} else {
			wait1Msec(650);
			zeroMotors();
			isClear = true;
		}
	}

	motor[motorFR] = -50;
	motor[motorFL] = -50;
	motor[motorBR] = -50;
	motor[motorBL] = -50;
	wait1Msec(1600);
	zeroMotors();
	wait1Msec(100);
	motor[motorFL] = -50;
	motor[motorFR] = 50;
	motor[motorBR] = -50;
	motor[motorBL] = 50;
	wait1Msec(1800);
	zeroMotors();
	while(true) {

	}
  //parkOnRamp(0);
 	//parkOnRamp(0);
  //Autonomous code goes here.
 }
